#  51学习笔记

## 1. 基础知识

###  1.1  电平特性

定义单片机为TTL电平：`高+5V，低0V`；

计算机`RS232`电平：`高-12V，低+12V`；

计算机与单片机通讯需要加入电平转换芯片`max232` ;

### 1.2  **二进制**

两种电平特性，全由`0、1`信号组成。

### 1.3  **十六进制**

**四个二进制数归为十六进制**,**先转换为十进制**，再转换为**十六进制**。

例如：`1001B->9D->9H`

再如：`0010 1100->44->2CH`,

### 1.4  **二进制运算**

&、|、^、！；

### 1.5  **51单片机介绍**

**STC89C52RC 40C-PDIP 0707** 

STC公司，8051内核，内部含Flash E2PROM存储器，CMOS产品，4KB*1内存大小

RC-内部RAM为512，外接晶振最高40MHz，AT系列一般为24MHz，商用级别双列直插式封装

07年第7周产

**总线（BUS）**：计算机各部件传送信息的公共通道

**内部总线：**CPU内部之间的连线

**外部总线：**CPU与其他部件间的连线

**三大总线：** **数据（Data Bus）、地址（Address Bus）、控制总线（Control Bus）**

**CPU：**运算与控制逻辑组成，包括中断与部分外部特殊功能存储器；

**RAM（Random Address Memory）：**存放可以读写的数据，运算的中间结果，最终结果及欲显示数据

**ROM  (Read Only Memory)：**存放程序、原始数据和表格；

**I/O：**4个8位并行I/O口，可以用作输入与输出

**T/C:**两个定时器/计数器，可以定时与计数

**5个中断源的控制系统；**

**一个全双工UART（通用异步接收发送器）的串行I/O**，实现单片机之间通信；

片内振荡器与时钟产生电路，**石英晶体与微调电容需要外接**；

### 1.6  **C51编程**

C是编译型程序设计语言，C语言开发可以缩短开发周期，增强程序可读性，便于改进与移植；

C语言程序本身不依赖于机器硬件系统，适应不同单片机，提供许多数学函数，方便计算；

**C相对汇编的优点：**

1. 不要求理解单片机指令系统，仅需了解8051的存储结构
2. 寄存器分配、不同存贮器寻址及数据类型的细节由编译器管理
3. 模块化程度高
4. 提供的库有很多子程序，有较强的数据处理能力
5. 容易移植

**数据类型：**`int、short、long、char、float、double`，前四个分为有符号无符号,`char、int`使用较多

​					要根据不同的大小选择类型；

类型扩充：

+ sfr：特殊功能寄存器声明`sfr SCON = 0x98`;
+ sfr16:sfr的16位数据声明`sfr16 T2 = 0xCC`;
+ sbit：特殊功能位声明`sbit OV = PSW^2`;仅声明寄存器其中第2位为OV
+ bit：位变量声明

**C-51头文件：**`reg51.h`,`reg52.h`,`math.h`,`ctype.h`,`stdio.h`,`stdlib.h`,`absacc.h`

## 2.Keil使用

### 2.1 新建project工程

**类似于C语言的.sln,C51也需要建立project工程，生成.uvproj文件，以链接所有文件，另外注意C语言编写文件后缀为.c**

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/Keil using/20221006191056.png" style="zoom:67%;" />

其他按钮及功能，另外右上角扳手左侧窗口用于隐藏某些菜单栏。

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/Keil using/keil按钮.png" style="zoom: 33%;" />

### 2.2 流水灯

程序编译Ctrl F7成功界面，对于51系列不要引用reg52.h库，会报错

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/Keil using/20221006192739.png" style="zoom:50%;" />

**先把文件保存再F7，执行编译，防止程序死机导致前功尽弃**

**值得注意：keil对于错误可能无法准确定位，一个错误会引出多个，找到最早的错误只能自己查找**

**代码说明：**

```c
#include <reg51.h>//引用库，相当于将库中所有内容复制到此
sbit  led1=P1^0;//头文件中定义sfr P1=0x90,此处必须为大写P
void main()//同C
{
	led1=0;
}
```

1. “reg51.h”也是引用库，是从当前文件夹下引用
2. 注释不参与编译

**闪烁原理：**LE置1，OE置0，Q将随D变化

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/Keil using/IMG_20221006_195105.jpg" style="zoom: 25%;" />

+ **P2为排阻**，一端为公共端的一串电阻，可以用作上拉电阻

  **tip：**电阻标号对应阻值，电阻标号末位为幂次 ，例如：`abcd=abc*10^d`；

​		三位标号精度为5%，四位为1%；

+ **D为二极管**：单向导电，3~20mA，因此P2排阻起限流作用，发光时二极管压降为1.7V，因此限流电阻阻值计算得（5-3.3）V/3mA=1100欧，减小此阻值，二极管会更亮
+ **U3为74HC573锁存器**，引脚与真值表

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/Keil using/74HC573.jpg)

OE为使能端，又叫三态允许控制端，D为输入Q为输出，OE为低电平才可控，**LE为低电平锁存**。

**OE与LE同低时，锁存，保持LE变低前的输出**。

**功能：锁存隔离**，可以LE置低锁死初始状态，某个模块不影响另外一个

**51上电时所有未控制的I/O口默认置高**；

输出设置：

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/Keil using/20221006202821.png" style="zoom:67%;" />

选中后，重新编译生成hex文件

**点亮多个灯，直接对P1口操作，0x0f表示P1口高4位置0，低4位置1，点亮4个；**

```c
#include <reg51.h>
void main()
{
	P1=0x0f;
}
```

### 2.3  循环

#### 2.3.1  while

2.2中的程序只执行一次，**但是对单片机需要重复执行，keil编译器遇到这种程序时会在主函数处重新执行，可能出问题**

**注意：单片机不能停止工作，只要晶振工作，每过一个机器周期，内部程序指针就需要+1，程序指针指向下一条待执行的指令，因此需要加死循环。**

```C
void main()
{
	P1=0x0f;
    while(1);
}
```

#### 2.3.2  for实现延时

**for循环常用来实现精确延时，但需要注意变量的类型**，unsigned char只能0~255，不要超出范围调用。

```c
#include <reg51.h>
#define uint unsigned int
uint i,j;
void main()
{
	while(1)
	{
		for(i=1000;i>0;i--)
				for(i=110;i>0;i--);
	}
}
```

主函数内不断执行延迟循环，模拟真实的时间需要根据单片机晶振频率，并对应于keil内设置

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/Keil using/20221006211305.png" style="zoom: 67%;" />

**精确时间调试部分：**

**查看端口：peripherals--I/O--选择对应IO口即可**

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/Keil using/20221006213946.png" style="zoom:50%;" />

在执行至`P1=0xff`时，其时间为0.0000422s，执行完嵌套for之后，其时间为0.968s，约为1s。

因此，在**变量类型为uint情况下**，内部循环110次，**外部i循环多少次，即可认为延迟多少ms**

可以设置一个变量time_count,作为参数判断循环次数,如下，**调用delay_1s(100)则延迟100ms**。

```C
#define uint unsigned int
uint i,j;
void delay_1s(uint time_count)
{
	for(i=time_count;i>0;i--)
		for(j=110;i>0;i--);
}
```

+ **时钟周期：**振荡周期，单片机外接晶振振频的倒数`T=1/f`,是**单片机最小的时间单位**，CPU基本工作脉冲;
+ **状态周期：**时钟周期2倍
+ **机器周期：****单片机基本操作周期**，为12个时钟周期，一个机器周期完成一个基本指令
+ **指令周期：**CPU执行一条指令所需时间，一般为1~4个机器周期

#### 2.3.3  左移实现

可以通过调用库`intrins.h`使用其内部的crol等移位函数

左移<<,右移>>同c语言，PSW寄存器CY位将存放移位前的最高位或者最低位（因为他们要溢出），如下图，**无论左移还是右移，溢出的1都会放在CY里。**

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/Keil using/20221007104554.png)

##### PSW寄存器

PSW全称Program Status Word，程序状态字标志位寄存器，字节地址为D0H，C编程时，编译器自动控制，无需额外操作

+ **CY**-进位标志，**最高位有进位或借位时置1，否则为0**
+ **AC**-进位辅助标志，判断**低四位是否有进位或借位**，有则置1，反之置0
+ **F0-用户控制的状态位**
+ **RS0、RS1-4组工作寄存器选择控制位**，用以选择寄存器中哪组为当前工作寄存器区
+ **OV-溢出标志位**，**带符号数**若有溢出，则置1，否则为0
+ **P-奇偶标志**，**累加器ACC**内容奇偶性，运算结果有偶数个**二进制1**，则P为0，否则为1

## EX01.**左移实现流水灯**：[点击查看](https://github.com/MicroPrism/Code-study-note/tree/main/C51/Basic_example/01_led_flash)

## 3.数码管

### 3.1 显示原理

对单个显示数码管，共10个引脚，7个显示数字8的每一段，1给显示小数点，2个接地（共阴极）或接5V（共阳极）。共阳极低电平有效，共阴高电平有效。

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/数码管原理.jpg)

注意：数码管驱动时不要使电流过大，可能烧毁二极管，可以加上拉电阻使用低电平驱动

#### 万用表测管脚号

万用表转到二极管档，红（接负极）、黑（接正极）线分别接数码管两个引脚，直至某段点亮，可以确定公共端与显示方式。

+ **编程时请注意while（1）死循环后是否有；**

  `warning C294: unreachable code`，程序卡在循环而不继续往下执行

## EX02.数码管静态显示[点击查看](https://github.com/MicroPrism/Code-study-note/tree/main/C51/Basic_example/02_display) 

## EX03.数码管动态显示[点击查看](https://github.com/MicroPrism/Code-study-note/tree/main/C51/Basic_example/03_dynamic_display)

### 3.2中断

**中断：**中断当前，执行中断程序

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/单级中断流程.jpg" style="zoom: 25%;" />

**嵌套中断：**

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/嵌套中断.jpg" style="zoom:25%;" />

**中断源表格：**

| 中断源                                         | 中断级别 | 序号（C） | 入口地址（汇编） |
| ---------------------------------------------- | -------- | --------- | ---------------- |
| INT0-外部中断0（P3.2，下降沿或者低电平）       | 最高     | 0         | 0003H            |
| T0-定时/计数器0中断（T0溢出回0）               |          | 1         | 000BH            |
| INT1-外部中断1（P3.3，下降沿或者低电平）       |          | 2         | 0013H            |
| T1-定时/计数器1中断（T1溢出回0）               |          | 3         | 001BH            |
| TI/RI-串行中断（完成一帧数据接收）             |          | 4         | 0023H            |
| T2-定时/计数器2中断**（52独有）**（T2溢出回0） | 最低     | 5         | 002BH            |

因为有优先级，因此在使用中断时必须设置中断允许寄存器IE（interrupt enable）和中断优先级寄存器IP（interrupt pirority）。

+ IE:一般进行位单独操作，需要使用哪个中断就让哪个置1

| 位序号     | D7   | D6   | D5   | D4   | D3   | D2   | D1   | D0   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **位符号** | EA   | --   | ET2  | ES   | ET1  | EX1  | ET0  | EX0  |
| **位地址** | AFH  | AEH  | ADH  | ACH  | ABH  | AAH  | A9H  | A8H  |

一般要使用哪个中断可以单独赋值`EA=1;EX0=1`，或者整体赋值`IE=0x81;`开总中断且开外部中断0；

+ IP：设置同IE，置1则放在高优先级

| 位序号     | D7   | D6   | D5   | D4   | D3   | D2   | D1   | D0   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **位符号** | --   | --   | --   | PS   | PT1  | PX1  | PT0  | PX0  |
| **位地址** | --   | --   | --   | BCH  | BBH  | BAH  | B9H  | B8H  |

高优先级可以打断低优先级，若设置`PS=1;`，则串口中断与外部中断同时作用时，串口优先

### 3.3定时器中断

**CPU开启定时器中断，晶振工作，定时器计时，计满之后中断。**

51内有两个16位（高8位+低8位）的定时器/计数器，**本质是+1计数器（因此需要赋初值）**。

#### 3.3.1相关寄存器

+ **TMOD（Timer Model）：工作方式寄存器**

| 位序号 | D7   | D6      | D5   | D4   | D3   | D2   | D1   | D0   |
| ------ | ---- | ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 位符号 | GATE | C/T(低) | M1   | M0   | GATE | C/T  | M1   | M0   |

高四位控制定时器1，低四位控制定时器0，GATE置1时，定时器受TCON与外部中断0、1同时控制**（门控，即受外部中断接口控制）**

C/T高计数，低定时

| M1   | M0   | Model                                  |
| ---- | ---- | -------------------------------------- |
| 0    | 0    | 13位定时/计数器**（8192微秒）**        |
| 0    | 1    | 16位定时/计数器**（65536微秒）**       |
| 1    | 0    | 8位初值重装定时/计数**（256微秒）**    |
| 1    | 1    | T1停止，T0分为双8位计时**（256微秒）** |

+ **TCON（Timer Control）：控制寄存器**，复位时清0

| 位序号 | D7   | D6   | D5   | D4   | D3   | D2   | D1   | D0   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 位符号 | TF1  | TR1  | TF0  | TR0  | IE1  | IT1  | IE0  | IT0  |
| 位地址 | 8FH  | 8EH  | 8DH  | 8CH  | 8BH  | 8AH  | 89H  | 88H  |

**TF1**：定时器1溢出时置1，同时申请中断，**定时模式进入中断自动清0**，若为**软件查询方式查到1后，需要软件置0**；

**TR1：**定时器运行控制位，软件清0关闭定时器。需要与TMOD门控配合。

|          | **GATE=1** | **INT1=1；启动** |
| -------- | ---------- | ---------------- |
| **TR=1** |            |                  |
|          | **GATE=0** | **启动**         |

**IE1：**外部中断1请求标志，若IT1为0，INT1为低电平时置1，IT1为1，第一个机器周期检测到INT1为0时置1

**IT1：**为**0**时为**电平触发**，为**1**时**跳变沿触发**

#### 3.3.2初值计算

定时器本身是+1加法器，不同工作方式有不同的加法上限，**对于12MHz晶振，每个机器周期为1微秒**，即使方式1（M1M0=01），**一轮最多也就65.5ms，如果想实现秒级，只能通过循环来实现**，例如1s，可以方式1计50ms循环20次，为了精确计50ms需要置初值。

对方式1 ：`TH0：（65536-50000）/256;TL0=（65536-50000）%256`，T1也一样。

执行1次加法需要一个机器周期，时间取决于晶振频率，对于11.0592MHz的晶振，单个机器周期为1.085微秒，若要计50ms，需要50000/1.085=46083个机器周期，也是46083次加法。

即：`TH0：（65536-46083）/256;TL0=（65536-46083）%256`

#### 3.3.3中断程序设计

**通用格式：**

```C
void 函数名() interrupt 中断号0~5  using 工作组
{
 	程序内容；   
}
```

**注意：**

+ **对TMOD赋值，确定工作方式**
+ **计算初值，放入TH0、TL0等**
+ **若采用中断，IE=1；**
+ **TR0，TR1在主程序置1，启动**

## EX4.定时器中断led闪烁[点击查看](https://github.com/MicroPrism/Code-study-note/tree/main/C51/Basic_example/04_timer_interrupt)

## EX5.定时器实现10分钟计时[点击查看](https://github.com/MicroPrism/Code-study-note/tree/main/C51/Basic_example/05_59s_timer)

## 4.键盘检测

### 4.1 独立键盘

常见键盘有回弹式（按下自动弹起），自锁式（按下不会自动回弹）相当于开关。

键盘按下与弹起时有抖动（5~10ms），因此需要加软件消抖或硬件消抖，即检测到按键按下时等待10ms再检测一次。

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/按键抖动信号.png" style="zoom:50%;" />

```C
//一般有以下格式，button为按键引脚
if(button==0)
{
    delay(10);
    if(button==0)；
    {
        while(!button);
        程序块;
    }
}
```

## Keil工程模块化

## [点此查看大致步骤](https://blog.csdn.net/qq_43732429/article/details/112448851)

+ 另需注意，STARTUP.A51文件需要放在user文件夹下，否则编译不通过

### 4.2矩阵键盘

单个键盘占一个引脚过于浪费，一个IO口也就8个引脚，最多8个开关，但是矩阵键盘，即4个引脚+4个引脚，类似于4个引脚做片选段，例如可以通过使某列置0（类似于单个按键接地），扫描每一行，即可确定该列是否有按键按下，依次对每列检测可以实现全部按键的检测。

## EX06.单个按键实现数码管计数

## EX07.矩阵键盘静态显示0~F

## 5.A/D与D/A转换

模拟量：温度、压力、位移、图像等，电子线路中模拟量包括模拟电压、模拟电流

幅值**随时间连续变化的量**属于模拟量，模拟量可以产生波形，但是波形并不确定，通常用十进制表示，比如2.3V，3.4A，4.5N等

单片机系统内部全是数字量，01二进制数，因此需要把模拟量转换为数字量进行操作，**位数越多，精度越高，比如00000~11111的5位二进制数，相当于将一个模拟量分为32份，每份表示特定值**，10位的，相当于分为2^10^=1024份，精度更高

单片机采集模拟信号时，需要加上模拟量/数字量转换（Analog to Digital），模数转换，同理，输出时，需要加上数模转换（Digital to Analog）

### 5.1 AD转换原理及参数

采样步骤：采样、保持、量化、编码

+ **采样定理：**f~采样~>=2f~原信号~，采样频率必须大于原信号最高频率分量的2倍

  通常采样频率取f~采~=（3-5）f~imax~，然后可以使用低通滤波器进行滤波，还原信号**。**

+ **量化和编码**：数字信号在时间与幅值上均是离散的，但是，每一个数字量都可以通过某个最小单元来倍乘得到，比如0~1V模拟电压，使用3位二进制码，最小单元为1/8V，001=1/8，100=1/2。

  **注意：**模拟到数字的转换为丢失一些信号，比如每个最小单元之间是无法测得的，而且会产生误差，最大量化误差为1/8V（0-1/8均对应0电平，最大可能是1/8）

  ![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/电平划分.jpg)

  如果采用右侧划分方法，最小单位为2/15，并且规定000对应模拟电压为0-1/15，可以将最大量化误差缩小为最小单元/2（1/15-3/15对应2/15电平，上下误差均为1/15，缩小一半）

+ **采样保持电路如下：**

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/采样保持电路.jpg" style="zoom: 25%;" />

​	使用N沟道MOS管作为采样开关，V~l~=1时，mos管导通，V~o~=V~i~，同时电容充电，即使mos管关断，电压将保存

​	**缺点：**电容C充放电需要时间，因此限制采样速度，Ri不能取的太小，否则将降低输入电阻

+ **采样-保持电路LE198**

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/LE198采样保持原理.jpg" style="zoom:25%;" />

A1，A2为集成放大器，L为VL的高电平开关，因此，VL=1，S导通时，Vo与Vi之间为电压跟随器，vo=vi，同时电容C充电，即使S断开，电容端电势仍为Vc=Vo，得以保持；

**D1，D2为二极管保护电路，当且仅当S未闭合（先前闭合过），VI变化，由于一级跟随器的反相端所接为Vo，所以当开关再次闭合时Vo‘的电压是未知的（如果所接是Vo’，能保持Vi跟随），为限制Vo‘，防止电路烧坏，令Vo'与Vo（=Vi）两端电压差超过压降VD时，二极管导通，反相端接入Vo’，实现Vo‘-VD对Vi的跟随，将Vo’限制在Vi+Vd**

#### 5.1.1并行AD转化

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/并行比较AD转换原理.jpg" style="zoom:25%;" />

**组成：电压比较器，寄存器，代码转换器，其参考电压为Vref，也是满量程，通过设置电阻大小实现单位划分，给定Vi时，比较电压小于等于Vi的比较器输出1，根据每个寄存器的状态，输出最终结果**

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/3位并行AD编码表.jpg" style="zoom:25%;" />

特点：

1. 转换是并行的，转换时间只受硬件（比较器、寄存器、代码转换器延迟时间）限制，转换速度快
2. 分辨率越高，所需元件个数越多，n位转换器需要2^n^-1个比较器，高位并行AD难搞
3. 比较器、寄存器含有采样保持功能，使用并行AD时，可以不用附加采样-保持电路

缺点：

1. 需要较多的比较器和寄存器，10位并行AD需要1023个寄存器和寄存器

#### 5.1.2反馈比较AD转化

反馈比较型构思：取数字量加到DA转换器，并将该结果与模拟电压比较，直至结果相等

**常见类型：计数型、逐次逼近型**

1. 计数型：

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/计数型AD转换.jpg" style="zoom:25%;" />

**原理：**被采集信号Vi（同相输入），开始时Vi=0，Vo=0;此后Vi=1，每次脉冲计数+1，Vo涨一个单位，直至Vi<Vo，与门锁，锁存器锁存输出。对于n位2进制码，如果待测Vi恰好位满量程，需要2^n^-1个时钟周期，而且每次测完后都需要清零重新计数，耗费时间

2. 逐次逼近型：

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/3位逐次逼近AD.jpg" style="zoom:25%;" />

**原理：****逐次逼近型是采用二分法进行查找**，例如四位主次逼近式，满量程16V，待比较为11.2V，则第一次查找为1000=8V，第二次查找为1100=12v，第三次查找为1010=10v，第四次，1011=11v

Vout=Vref（B0/16+B1/8+B2/4+B3/2）；依次让Bi为1，Vout小则保留1，否则为0，继续下一个Bi的比较

每个结果都分叉1000-1100/0100…

#### 5.1.3 AD参数

对于AD转换器来说，转换精度和转换时间更加重要

1. **分辨率：**对于n位AD，为满量程的1/2^n^,一般是最小单位

2. **转换误差：**实际输出数字量与理论输出数字量之间差别，一般用最低有效位表示。相对误差<=|LSB/2|，表示误差小于最低位的一半

3. **转换精度：**AD转换的最大量化误差与模拟部分精度共同组成

   10位全量程相对误差为--最大量程误差/全量程*100% ,即`【（1/2^10)*满量程*0.5 】/满量程*100%`,其中【】内为最大量化误差

4. **转换时间：**从转换控制信号开始时到输出端得到稳定的数字信号经过的时间

**例：要求1s对16个热电偶的输出电压完成分时AD转换，热电偶输出电压范围0-0.025V（0-450°），需要分辨温度为0.1°，需要多少位AD转换器，转换时间为多少；**

**分辨率：0.1/450=1/4500>1/2^13^,需要13位，1s完成16个转换，故转换时间应小于1/16=62.5ms**

### 5.2 DA转换原理及参数

#### 5.2.1 DA转换原理

DA转换与AD转换类似，即二进制码与模拟量的对应，本质思想是**数字量对应的最小单位电压和=模拟电压**，比如8位AD，就是将参考电压分为255份，然后输出模拟电压的数字量，或者说最小单位份数的二进制码。

DA同理，不过DA的输入是二进制码，给定参考电压（最小单位电压）时，二进制码对应的份数与之相乘即可。

#### 5.5.2  权电阻网络

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/权电阻网络DA.jpg" style="zoom:25%;" />

原理分析：两种理解方式 

1. **电流和**

   v~o~=-R~f~*(I~1~+I~2~+I~3~+I~0~);

   **其中每一支路电流不同，I~i~=V~ref~/R~i~，但是均与V~ref~相关**，可以表示为

   v~o~=-V~ref~/2^4^*(2^3^d~3~+2^2^d~2~+2d~1~+d~0~)=-V~ref~/2^4^D~n~;实现从数字量D~n~到模拟输出v~o~的转换

2. **反相放大器线性叠加**

   **将权电阻网络理解为多个反相比例放大器的线性叠加**，每个支路的输出分量为v~oi~=-V~ref~R~f~/R~i~；

**输出电压与参考电压间有负值关系，可在参考电压端加负号**

**缺点：大电阻不易于集成，电阻阻值间相差过大，4位都相差8倍，结果不准确**

优点：简单，可显示0- （-2^n^-1)*V~ref~/2^4^范围的模拟电压

#### 5.2.3 倒T型电阻网络DA

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/4位倒T型DA.jpg" style="zoom:25%;" />

**原理：电阻两端无论如何都处于并联分压状态，不能将其再视为比例放大器的叠加，而应该使用电流和分析。**

**左侧两个并联电阻等效阻值为R，串联R后阻值为2R，再与下一个并联等效，依次往后，等效结果为R，因此总电流I=V~ref~/R，每一支路的电流如图所示（并联分流），刚好是倍数关系，当对应开关接通时，支路电流参与求和**

**v~o~=-V~ref~/2^4^R  *(2^3^d~3~+2^2^d~2~+2d~1~+d~0~) *R~f~=-R~f~/R2^4^ *D**

电路参数要求：

1. 基准电压稳定---不论对于什么电路，基准电压都应该稳定，这决定了每次转换的参照值
2. 倒T型网络电阻R与2R比值精度高---电路的主要思想是等效，不断的串联并联等效，等效出的电阻精度必然会受影响
3. 模拟开关的压降要相等。为实现支路电流呈2倍变化，模拟开关的电阻应该为0.5倍变化。---目的尚不理解，暂且理解为，为方便计算，规定压降相等，以确定支路电流与开关电阻变化关系，尽量提高精度

相对于权电阻网络：

1. 无论开关是否闭合，电流I~i~是恒定的，而权电阻网络开关闭合时电流0->I~i~,会产生尖脉冲

缺点：模拟开关导通电阻、压降参数难以确定，会产生误差，影响精度

升级版：

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/权电流DA.jpg" style="zoom:25%;" />

以恒流源作为分支，每个支路电流不再受压降影响，只需要令恒流源倍数变化即可，结果更准确。

#### 5.2.4双极DA转换

<img src="双极型DA.jpg" alt="双极型DA" style="zoom:25%;" />

双极型的关键是V~B~偏移电流与G反相器，为加G前，显示的为下图左侧输出0-7V，加上偏移电压V~B~后，将0-7V变为-4-3V，V~B~=V~ref~R~B~/2R，保证器为参考电压的一半即可。

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/输出值.jpg" style="zoom:25%;" />

但是偏移之后并不方便记忆与实现，于是在最高位加反相器

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/双极型高位取反.jpg" style="zoom:25%;" />

高位取反后，以补码形式存储刚好可以一一对应份数与极性，其中最高位只表示符号位。

111-》101-》-3V；101-》111-》-1V；011-》011-》3V

#### 5.2.5 DA参数

1. 分辨率：n位能分辨的为1/(2^n^-1),最小位为1时与全为1时比值，与位数相关

2. 转换误差：实际输出与理论输出差值

   DA绝对误差：指全1时输出端实际值与理论值之差，应<LSB/2

   对8位DA，最大输出为255/256 *V~ref~，LSB/2=V~ref~/512，实际结果应在最大+-LSB/2

3. 转换时间：数字输入到稳定模拟输出

## EX08.AD0804模数转换

[AD0804模数转换](https://github.com/MicroPrism/Code-study-note/tree/main/C51/Basic_example/08_AD)

## EX09.DA0832数模转换

[DA0832数模转换](https://github.com/MicroPrism/Code-study-note/tree/main/C51/Basic_example/09_DA0832)

## 6.串行口通信

### 6.1基本通信方式

#### 6.1.1 并行通信

并行通信，**一个字节数据使用多条数据线进行传输，每一位数据都需要一条传输线。**

8位数据总线的系统，一次传送8位，一个字节数据。

另外，需要一根信号线与若干控制信号线。仅仅适用于短距离传输。

并行通信控制简单，传输速度快，但是传输线较多，长距离传输成本高，收发方同时接收存在困难。

#### 6.1.2 串行通信

串行通信是将数据字节按位传输，只有一条数据线，一条公共地线与若干控制线，一个字节数据至少要分8位才能传输完成，D0-D7依次传输。

串行通信必须过程：

​		发送时：并行数据变为串行发送到线路上

​		接收时：串行变为并行

串行通信传输线少，长距离传输成本低，数据传送控制比并行通信复杂。

#### 6.1.3 异步串行通信

**异步串行**是指通信的**发送与接收设备使用各自的时钟控制**发送接收过程，为使收发协调，尽可能的时时钟一致.

**异步通信**是**以字符构成的帧为单位**，字符与字符间的间隔是任意的，每个字符中的各位以固定时间传送，**第n与n+1个字符间的间隔不一定为位间隔的整数倍，但是第n个字符内部的位之间间隔为位的整数倍**。

一帧字符：起始位、数据位、奇偶校验位、停止位，有的字符信息带空闲位格式，如图

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/异步通信.jpg)

**异步特点：**不要求收发时钟严格一致，实现容易，开销小，**每个字符间要增加3位，起始、停止、校验**，**各字符帧之间还有间隔，传输效率不高。**

#### 6.1.4 同步串行通信

**同步串行要求数据发送方与数据接收方有直接控制，双方完全同步**，传输数据的位之间距离为位间隔的整数倍。

传送字符间没有缝隙(空闲字符)，发送数据对接收方的同步包括自同步与外同步。

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/异步通信.jpg" style="zoom:25%;" />

**面向字符同步：**

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/字符同步.jpg)

**此时传输的数据必须由规定的字符集--ASCII码中字符组成**。

+ 帧头为1-2个SYN同步字符(ASCII=16H)。

+ SOH为序使字符(01H)，表示为标题开始，标题包含源地址、目标地址与路由指示信息。
+ STX为文始字符，表示传送数据块的开始。
+ 数据块是正文内容，包含多个字符。
+ 数据块后为组终字符ETB/文终字符ETX(17H/03H)，然后是校验码。

典型面向字符同步规程如IBM的二进制同步规程BSC。

**面向位同步：**

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/位同步.jpg" style="zoom:25%;" />

规定序列01111110为起始和终止标志，将数据块看作数据流。

**为避免在数据留中出现01111110序列引起混乱，发送方在数据流中每5个连续的1就插入一个0；接收方则连续5个1，1个0时，删除0。**

面向位的同步协议如ISO的高级数据链路控制规程HDLC和IBM的同步数据链路控制规程SDLC。

**特点：数据位长度任意，起始终止为为固定序列，传输效率高，但是硬件复杂。**

#### 6.1.5 串行通信制式

+ 单工：数据只能单向传输
+ 半双工：数据可以双向传输，但是不能同时传输
+ 全双工：可以同时双向传输

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/传输方式.jpg)

#### 6.1.6 串行通信错误校验

1. 奇偶校验

   + 发送数据时，数据位尾随的一位为奇偶校验位(1或0).

     + 奇校验：数据位与校验位中1的个数和为奇数

     + 偶校验：为偶数

   + 接收数据时，对1个个数进行校验，若不一致，则出错

2. 代码和校验 

   发送方将所发数据块求和（或异或），产生一个字节校验字符附加到数据块末尾。

   接收方接收数据时同时对其求和（或异或），将结果与发送方的比较，不一致则出错。

3. 循环冗余检验

   通过某种数学运算实现有效信息与检验位之间的循环校验，常用于对磁盘信息的传输、存储区的完整性校验，纠错能力强，应用广泛。

### 6.2 RS232转TTL

[点此查看]

### 6.3波特率与定时器初值

#### 6.3.1 波特率

**波特率：每秒传输二进制代码的位数**，1波特=1位/秒，单位为bps，位每秒。

串行信息流的最大距离与波特率也有关，每0.3m有50pF电容非平衡屏蔽双绞线时，9600bps最大距离为76m。

因此，**数据传输时尽量缩短数据线长度**。

#### 6.3.2 波特率计算

单片机串行口的通信方式有4种，**方式0与方式2的波特率固定，方式1与方式3的波特率可变，由定时器溢出率决定。**

+ 方式0波特率=f~osc~/2
+ 方式1...=(2^SMOD^/32)*(T1溢出率)
+ 方式2...=(2^SMOD^/64)*f~osc~
+ 方式3...=(2^SMOD^/32)*(T1溢出率)

f~osc~为系统晶振频率，通常为12MHZ/11.0592MHZ；SMOD是PCON寄存器 的最高位。

#### 电源管理寄存器PCON

**PCON字节地址为87H，不能位寻址**，PCON管理电源部分，包括上电复位、掉电、空闲等，单片机复位时其清0。

| 位序号 | D7   | D6        | D5      | D4       | D3   | D2   | D1   | D0   |
| ------ | ---- | --------- | ------- | -------- | ---- | ---- | ---- | ---- |
| 位符号 | SMOD | —(SMOD0） | —(LVDF) | —（P0F） | GF1  | GF0  | PD   | IDL  |

+ SMOD：SMOD=0,方式123波特率正常，SMOD=1，方式123波特率加倍
+ SMOD0、LVDF、P0F为STC独有功能，其他单片机未使用。
+ GF1、GF0：通用工作标志位，用户自由使用
+ PD：掉电设置位，PD=0：正常；PD=1：掉电（Power Down），可由外部中断低电平/下降沿触发或硬件唤醒，掉电模式后，外部晶振停止，CPU、定时器、串行口均停工，外部中断继续工作。
+ IDL：空闲模式设定，IDL=0，正常；IDL=1，进入空闲模式（Idle），仅CPU不工作，可由任一个中断或硬件复位唤醒。

**T1溢出率与初值有关，第三章定时器也有提到。若设定T1定时器50ms溢出一次，则溢出率位20Hz**，带入公式得出波特率，两者可以相互转化。

当需要较高波特率时，T1溢出率较高，定时中断函数重装初值时，进入中断、装值、出中断容易产生微小时间差。

解决办法：定时器方式2，8位自动重装的8位定时器/计数器，相对于方式1在中断中装初值，方式2溢出后自动重装。

使用方式2时，TH=TL，溢出后TL初值从TH获得。

**波特率计算如下：**

例：串口方式1，波特率9600bps，SMOD=0，系统晶振11.0592MHz，求TH与TL初值。

初值为x，256-x次计数后溢出，此时经过[256-x]*12/11.0592MHz个时钟周期（1次计数需要1个机器周期）。

即9600=1/32*溢出率，解得SMOD=0时，X=253，SMOD=1时，X=250.

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/常用波特率初值.jpg)

若使用12MHz或6MHz，计算出的T1定时器初值不是整数，会产生误差。

### 6.4 51串行口接收

#### 6.4.1 串行口结构

51串行口是**可编程全双工**的通信接口，具有UART的全部功能，同时进行数据收发，也可做同步移位寄存器

主要由两个独立的串行数据缓存寄存器SBUF(发送缓存寄存器+接收缓存寄存器)、发送控制器、接收控制器、输入移位寄存器及若干控制门电路。

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/串行口结构.jpg" style="zoom: 25%;" />

SBUF可以对串行收发寄存器进行访问，执行写指令时，访问发送控制器；读指令，访问接收控制器。

接收器具有双缓冲结构，在从接收寄存器中读出一个字节前，便能接收第二个字节，**如果第二字节已经发送，第一个字节没有读出，则将丢失其中一个字节。**发送时靠CPU执行，无需担心。

#### 串行口控制寄存器SCON

SCON(Serial Control)字节地址98H，可位寻址。

| 位序号 | D7   | D6   | D5   | D4   | D3   | D2   | D1   | D0   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 位符号 | SM0  | SM1  | SM2  | REN  | TB8  | RB8  | TI   | RI   |

| SM0  | SM1  | 方式 | 功能                                |
| ---- | ---- | ---- | ----------------------------------- |
| 0    | 0    | 0    | 同步移位寄存器（用于IO扩展）        |
| 0    | 1    | 1    | 10位异步收发（8位数据），波特率可变 |
| 1    | 0    | 2    | 11位异步收发，波特率固定            |
| 1    | 1    | 3    | 11位异步收发，波特率可变            |

+ SM2：多机通信控制位，主要用于方式2与方式3。

  + 接收机SM2=1时，利用RB8控制是否激活RI。
    + RB8=0，不激活RI，信息丢弃
    + RB8=1，激活RI，收到的数据进入SBUF，在中断服务中将数据从SBUF读走
  + SM2=0时，无论RB8为何值，均可使收到的数据进入SBUF，激活RI。

  方式0时，必须SM2=0；方式1时，若SM2=1，接收到有效停止位，RI置1。

+ REN:允许串行接收控制位,REN=1,允许接收；否则，不允许接收。

+ TB8：方式23中发送数据的第9位，可做数据奇偶校验位，多机通信可以作为地址帧数据帧标志位。

  ​			方式01中不使用。

+ RB8：方式23中接收数据第9位，可做奇偶校验位。方式1时，若SM2=0，RB8为接收到的停止位。

+ TI：发送中断标志位

  + 方式0串行发送8位数据结束时，或其他方式停止位发送开始时，内部硬件TI置1，向CPU发中断申请，但中断内部需要软件清0，取消申请。

+ RI：接收中断标志位

  + 类似TI，不过是接收数据，也需要中断内部软件置0。

#### 6.4.2 串口方式

+ 方式0：同步移位寄存器输入输出，用于扩展IO。数据由RXD输入，同步移位脉冲由TXD引脚输出。收发均为8位数据，先低后高，波特率为f~osc~/12。
+ 方式1：10位数据异步通信口，1+8+1。TXD为数据发送口，RXD为数据接收口，波特率可变，大多也使用方式1。
+ 方式2，3：11位异步通信。TXD发送，RXD发送，1+9+1，其中9位数据中有1位附加的TB8/RB8.
  + 方式2波特率固定位晶振频率1/64或1/32，方式3固定
  + 方式23接收到的停止位与SBUF、RB8及RI无关。

## EX10.串口通信

[传输字符](https://github.com/MicroPrism/Code-study-note/tree/main/C51/Basic_example/10_Serial_char)

## EX11.串口通信控制

[上位机控制输出](https://github.com/MicroPrism/Code-study-note/tree/main/C51/Basic_example/11_Serial_voltage)

## 7.通用型液晶使用

### 7.1液晶概述

液晶显示器(Liquid Crystal Display)LCD,名称通常与行列有关，LCD1602，但是只能显示ASCII码字符。

12232属于图形型液晶，122列32行，可以控制任何一个点显示或者不显示。

液晶功耗小，但使用温度范围有限，0-+50°C，设计时需要考虑液晶型号。一般分为串行口与并行口。

### 7.2常用1602

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/1602接口说明.jpg" style="zoom:25%;" />

| 容量         | 16*2        |
| ------------ | ----------- |
| 芯片工作电压 | 4.5-5.5V    |
| 工作电流     | 2mA（5.0V） |
| 最佳电压     | 5V          |
| 字符尺寸     | 2.95*4.35   |

#### 7.2.1基本操作时序

| 读状态 | RS=L，R/W=H，E=H                    | D0-D7=状态字 |
| ------ | ----------------------------------- | ------------ |
| 读数据 | RS=H，R/W=H，E=H                    | 无           |
| 写指令 | RS=L，R/W=L，D0-D7=指令码，E=高脉冲 | D0-D7=数据   |
| 写数据 | RS=H，R/W=L，D0-D7=数据，E=高脉冲   | 无           |

控制器内部有80B的映射，一行40个（0-27，40-67），但是只能显示16个，余下24个需要移屏指令才能显示。

#### 7.2.2 状态字、数据指针与其他设置

状态字共8个从STA0-STA7，对应位地址为D0-D7，STA0-STA6为当前地址指针的值，STA7为使能端，为允许。

原则上每次读写之前需要进行读写检测，但是单片机操作速度小于显示速度，因此只需要短暂延时。

80H+地址码（0-27H，40-67H）可以设置数据地址指针.

01H：显示清屏，1.数据指针清0  2.所有显示清0

02H：显示回车，数据指针清0

#### 7.2.3 初始化设置

1. 显示模式

   指令码：00111000(0x38),设置16*2显示，5 * 7点阵，8位数据接口

2. 显示光标设置

   | 指   |      | 令   |      | 码   |      |      |      | 功能                                                 |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---------------------------------------------------- |
   | 0    | 0    | 0    | 0    | 1    | D    | C    | B    | D=1;开显示；C=1显示光标；B=1光标闪烁                 |
   | 0    | 0    | 0    | 0    | 0    | 1    | N    | S    | N=1,读/写字符后地址+1，且光标+1；N=0，地址-1，光标-1 |
   | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 0    | 光标左移                                             |
   | 0    | 0    | 0    | 1    | 0    | 1    | 0    | 0    | 光标右移                                             |
   | 0    | 0    | 0    | 1    | 1    | 0    | 0    | 0    | 整屏左移，光标跟随                                   |
   | 0    | 0    | 0    | 1    | 1    | 1    | 0    | 0    | 整屏右移，光标跟随                                   |

#### 7.2.4写操作时序

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/1602写时序.jpg)

1. RS=0/1,确定是写命令/数据

2. R/W置低，写模式
3. 传输数据
4. E产生高脉冲

### 7.3 常用12232

#### 7.3.1 基本信息

+ 并行

  <img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12232并行接口.jpg" style="zoom:25%;" />

  并行接法需要接8个数字输入

+ 串行

  <img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12232串行接口.jpg" style="zoom:25%;" />

  串行需要接SCL、CS、MOSI三个引脚，不再接RS、R/W判断是写还是读。

+ 参数说明

  <img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12232主要参数.jpg" style="zoom:25%;" />

+ 并行基本时序

  | 读状态 | RS=L，R/W=H；E=H                    | D0-D7=状态字 |
  | ------ | ----------------------------------- | ------------ |
  | 读数据 | RS=H，R/W=H；E=H                    | -            |
  | 写指令 | RS=L，R/W=L；D0-D7=指令码，E=高脉冲 | D0-D7=数据   |
  | 写数据 | RS=H，R/W=L；D0-D7=数据，E=高脉冲   | -            |

+ 忙标志BF

  BF=0为准备状态，BF=1内部正在操作，不接受外部信息。

+ 字形产生ROM（CGROM）

  CGROM=8192个触发器，DFF=1为开显示，将DDRAM内容显示在屏幕上，DFF=0关显示。

  DFF状态由DISPAY ON/OFF和RST控制。

+ 显示数据RAM（DDRAM）

  模块内显示RAM最多显示64字符，写入显示数据时可以显示CGROM与CGRAM字型，模块可以显示3种字型，包括英数字型、CGRAM、CGROM中文字型。字型选择由DDRAM编码确定，00-0F为CGRAM、10-7F为英数字型、A0以上的编码显示中文字型

+ 字型产生RAM

  该RAM可以造字，可以提供四组16*16的自定义空间。

+ 地址计数器AC

  存储DDRAM与CGRAM地址，每次读写后地址+1，RS=0，R/W=1时，将被读取到DB6-DB0。

+ 游标/闪烁控制电路

  地址计数器的值指定DDRAM种游标闪烁位置

+ 状态字

  | STA7      | STA6     | STA5          | STA4 | STA3 | STA2 | STA1 | STA0 |
  | --------- | -------- | ------------- | ---- | ---- | ---- | ---- | ---- |
  | STA0-STA6 | 存放当前 | 地址指针值    |      |      |      |      |      |
  | STA7      | 读写使能 | 1-禁止，0允许 |      |      |      |      |      |

  理应进行读写检测，单片机读写速度小于液晶反映速度，只需短暂延时

+ 指令码

  ![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12232指令码.jpg)

  ![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12232指令码2.jpg)

  RE=1时可以进行指令扩充。

+ 并行写时序

  ![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12232并行写时序.jpg)

  同1602

+ 串行写时序

  ![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12232串行写时序.jpg)
  + CS：片选拉高
  + SCLK：串行时钟，每操作一个位数据均需要有SCLK跳变沿，上升沿有效
  + SID：串行数据，一次操作3字节
    + 第一字节：指令码-确定读写
    + 第二字节：高4位存放数据高4位
    + 第三字节：低4位存放数据低4位 

### 7.4 12864

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12864引脚说明.png)

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12864主要参数.png)

#### 7.4.1并行基本操作时序
​        读状态 输入：RS=L，R/W=H，E=H 输出：D0~D7=状态字。
​        读数据 输入：RS=H，R/W=H，E=H 输出：无。
​        写指令 输入：RS=L，R/W=L，D0~D7=指令码，E=高脉冲 输出：D0~D7=数据。
​        写数据 输入：RS=H，R/W=L，D0~D7=数据，E=高脉冲 输出：无。

#### 7.4.2 忙标志(BF)
​        BF标志提供内部工作情况，BF=1表示模块在进行内部操作，此时模块不接受外部指令和数据。BF=0时，模块为准备状态，随时可接受外部指令和数据。
​        **利用STATUSRD指令，可以将BF读到DB7总线来检验模块的工作状态。**

#### 7.4.3 状态字与指令

<img src="https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12864状态字.png"  />

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12864指令说明.png)

#### 7.4.4 液晶显示坐标

1. 图形显示坐标，xy坐标系

   绘图128*8B的空间，更改绘图RAM时，先写入水平垂直的坐标值，再写入两字节的坐标值，地址计数器自动+1；写入绘图RAM器件，绘图显示必须关闭

   写入绘图RAM步骤如下：

   + 关闭绘图显示
   + 水平位元组坐标(x)写入RAM地址
   + 垂直Y
   + D15-D8写入RAM
   + D7-D0写入RAM
   + 打开绘图显示

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12864液晶绘图显示坐标.png)

2. 汉字显示坐标

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12864汉字坐标.png)

#### 7.4.5时序

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12864并行时序.png)

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/12864串行时序.png)

## 8.IIC总线

### 8.1 IIC概述

IIC=I^2^C=Intel IC Bus,属于同步通信形式，主从通信时，可以有多个IIC总线器件接到IIC总线。

所有与IIC兼容的器件都具有标准接口，**通过地址识别对象**，可以相互通信。

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/IIC基本结构.png)

IIC总线有SDA数据线与SCL时钟线构成通信线路，可以发送数据，也可传输数据。

主从IC，IC之间均可以相互通信，CPU发出 的控制信号分为地址码与数据码两部分，地址码用于选址，数据码选通内容。

SCL(P1^ 6)、SDA(P1^7)均为漏极开路，需要上拉电阻。**总线在空闲状态均为高电平，总线上器件任意一个输出低电平，总线电平将拉低。**

IIC：多主通信，主从通信。主从通信只有一个主器件（单片机），其他都为从器件，**主从方式中主器件启动数据发送，产生时钟信号，发出停止信号。**

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/IIC通信时序.png)

+ 有效位规定

  **SCK高电平期间，SDA数据必须稳定，SCK低电平，SDA数据才可变**

+ 启动信号

  一次数据传输中，主机发出启动信号，启动IIC总线，**SCL高电平期间，SDA出现下降沿则为启动信号**。

  ![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/IIC启动时序.png)

+ 寻址信号

  主机发出启动信号后，才会发出寻址信号。期间地址分为7位与10位。

  以7位为例，一个字节用于放地址，高7位为地址，低1位为方向位，方向位为0，主机对从器件进行写操作，否则进行读操作。

  **主机发送地址时，每个从机都将以该信号对比自身地址，并根据末位确定自身为发送机还是接收机。**

  从机地址由固定部分与可编程部分组成，**一个系统从机可编程部分决定了可接入总线该类器件的最大数目。**（比如接入多个BMP388）

+ 应答信号

  IIC总线规定，每传输一个字节数据后，都需要一个应答信号（包括地址与命令字）确定数据是否接收。

  应答信号由从机产生，**在SCL信号为高电平期间，从机将SDA拉低**，表示应答。（通常从机SDA为高电平）

+ 非应答信号

  主机为接收设备时，对最后一个字节不应答，向发送设备表示数据传输结束

+ 停止信号

  所有数据均传输完成，**SCL高电平期间SDA产生上升沿信号**。

  ![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/IIC传输过程.png)

  **数据传输过程为上图**

### 8.2 模拟IIC通信

模拟IIC是通过软件模拟通信时序

```C
//1.拉高SDA与SCL，IIC初始化
void init()
{
    SCL=1;
    delay();
    SDA=1;
    delay();
}
//2.启动信号--SCL=1,SDA产生高电平
void start()
{
    SDA=1;
    delay();
    SCL=1;
    delay();
    SDA=0;
    delay();
}
//3.应答信号--SCL=1,从机SDA下降沿
void respons()
{
    uchar i;
    SCL=1;
    delay();
    while((SDA==1)&&(i<255))
        i++;//等待后默认已经应答
    delay();
    SCL=0;
    delay();
}
//4.停止信号,SCL=1,SDA模拟上升沿
void stop()
{
	SDA=0;
    delay();
    SCL=1;
    delay();
    SDA=1;
}
//5.写一个字节-temp左移，最高位存入PSW的最高位CY中
void writebyte(uchar dat)
{
    uchar i,temp;
    temp=dat;
    for(i=0;i<8;i++)
    {
        temp=temp<<1;
        SCL=0;
        delay();
        SDA=CY;//循环移位实现对最高位的读取
        delay();
        SCL=1;
        delay();
    }
    SCL=0;
    delay();
    SDA=1;
    delay();
}
//6.读一字节
uchar readbyte()
{
    uchar i;
    SCL=0;
    delay();
    SDA=1;
    for(i=0;i<8;i++)
    {
        SCL=1;
        delay();
        k=(k<<1)|SDA;//局部变量不断按位或，通过移位实现8位存放
        SCL=0;
        delay();
    }
    delay();
    return k;
}
```

### 8.3 E^2^PROM AT24C02与单片机通信实例

采用EEPROM是为解决掉电保护问题，使用普通存储器需要增加备用电池与掉电检测硬件电路。

AT24C02共8个引脚，其中A0-A3为可编程数据端，接确定的高低电平以确定期间位置。

WP：写保护电平，当为低电平时，进行正常读写。为高电平时，只读。

#### 8.3.1 存储结构与寻址

AT24C02内部共2Kb，内部32页，每页8个字节，寻址方式包括：芯片寻址，片内子地址寻址。

+ 芯片寻址：芯片地址为1010，地址控制字格式1010A2A1A0RW,A0-A3为可编程控制位，RW为读写控制位，低电平为写。
+ 片内子地址寻址：片内寻址可对片内256B任意一个进行读写，寻址范围为00-FF

#### 8.3.2 读写时序

串行E^2^PROM一般有两种写入方式：字节写入与页写入，页写入需要注意允许在一个写周期（10ms）进行一页8B连续写操作。为避免”上卷“，当页8B写完后将从当前页第一个字节重新写，导致数据覆盖。

避免方式：写入后地址强制加1，或者将下一页首地址赋值给寄存器。

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/20221025214130.png)

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/20221025214157.png)

**字节写入与页写入略有不同，页写入在完成一个字节写入后并不立即停止stop信号，而是继续进行下一字节的传输。**

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/指定地址写.jpg)

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/指定地址连续写.jpg)

指定地址读时也类似，不过在确定器件地址（写）并应答后，下一字节传输指定的地址。待应答后再有一个新的启动信号，确定器件地址（读），传输数据。

单片机写指定地址，从机应答。从机读该地址，字节数据通过sda传输至单片机。相当于是两个过程，因此需要两个启动信号。

## 9.运放

运算放大器Operation Amplifier(OA),对微弱信号进行放大，可做反向器，电压比较器，跟随器等

### 9.1 参数

1. 放大倍数：输出信号与输入信号的比值
2. 增益：等同于放大倍数，单位为dB
3. 最大输出电压U~OPP~：输出输入保持不失真关系的最大输出电压
4. 输入失调电压U~OS~：室温及标准电压下，使U~O~为0，在输入端加入的补偿电压值。反映电路对称程度与电位配置情况。
5. 输入失调电流I~OS~：室温及标准电压下，使U~O~=0，两输入端电流差。
6. 输入偏置电流I~B~：恒流源驱动输入端，室温及标准电压下，使U~O~=0，两输入端的平均电流值
7. 开环差模电压增益A~uo~：运放没有接反馈时差模电压放大倍数，A~uo~越高，运算电路越稳定，精度越高。
8. 单位增益带宽：增益带宽=增益*带宽，单位增益带宽是指闭环增益为1时所输出的放大倍数变成0.707倍时，输入信号的频率
9. 最大差模输入电压U~idm~：运放两端所能承受的最大电压差值，超过该值，将出现PN结反向击穿
10. 差模输入电阻：开环运放两输入端差模信号的动态电阻。
11. 最大共模输入电压U~icm~：标准电压下，两输入端在相同电位时的最大输入电压，超过此值时，共模抑制比将下降
12. 共模抑制比CMRR：运放开环差模电压放大倍数与共模电压放大倍数之比。
13. 共模输入电阻：每个输入端到地的共模动态电阻。
14. 转换速率SR：表示运放对阶跃信号输入的反映能力，在额定打信号输出电压时，运放输出的最大变化速率。
15. 全功率带宽f~pp~：正弦输入且运放接成电压跟随器状态时，额定输出电流及规定失真条件下的额定输出电压对应的带宽。

**放大倍数：**

​	电压：倍数=UO/UI ，增益=**20**lg倍数（dB）

​	电流：倍数=IO/II ，增益=**20**lg倍数（dB）

​	电压：倍数=PO/PI ，增益=**10**lg倍数（dB）

优势：

1. 读写方便，将上万倍的放大倍数转化为较小的数
2. 方便计数，放大器级联时，总放大倍数相乘，但增益只需要相加

### 9.2 放大器

#### 9.2.1 反相放大器

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/反相放大器.png)

该电路为单电源形式，一个VCC，另一个接地。当Uin为正值时，理论应该输出负电压，但是电路中没有接-VCC而是接地，所以输出不可能为负值。Uin为负值时，可以正常输出正值电压。

当输入为关于0电位对称的三角波与正弦波时，将呈现反相输出。

**运放同相接地串联R2，目的是减小输入偏置电流带来的失调电压**。通常取R1与Rf并联后的值。（输出失调电压=输入失调电压*增益）

**运放输入端失调电压来源：**

1. **输入偏置电流**：输入失调电流带来的失调电压与电路结构有关。在**不使用调整电路的情况下减小失调电流，应使同、反相端对地的电阻相等（R2=Rf//R1），使偏置电流在输入电阻上带来的压降带来的失调电压相互抵消。**
2. **输入失调电压：对于给定运放，输入失调电压就确定死了**

**低内阻信号源放大器中，输入失调电压是主要误差。高内阻信号源放大器中，偏置电流在信号源内阻上的压降成为误差主要来源。**

高输入阻抗的情况下，失调电压采用R2的阻值来调整，利用电阻压降减小输入失调电压。

**交流耦合时，失调电压并不是太重要，主要问题：失调电压减小了输出电压峰-峰值动态范围。**

#### 9.2.2 同相放大器

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/同相放大器.png)

输入信号接在同相端**，输入与输出信号同相，输入阻抗为运放差模输入阻抗与环路增益的乘积。（环路增益=开环增益/闭环增益）。**

直流耦合情况下，输入阻抗对于运放的影响比起输入电流，在次要地位。其他均与反相放大器相同，**输入端悬浮的情况下，电路输出可能饱和。**

#### 9.2.3 电压跟随器

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/电压跟随器.png)

电路的输出电压与输入电压是相同的，电路中起缓冲、隔离、提高带载能力的作用。

**运放特点：高输入阻抗，低输出阻抗，相当于对前级电路开路，而对后级电路相当于提供了一个恒压源，输出电压不受后级电路阻抗影响，起到隔离作用。**

#### 9.2.4 加法器

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/加法器.png)

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/加法器输入输出.png)

#### 9.2.5 差分放大器

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/差分放大器.png)

差分电路是对求和电路的发展，可以减小甚至去除两个输入信号的共模成分。

**反相输出=-R2/R1 *U1**

**同相输出=（R1+R2）/R1* U2',其中U2‘为U2分压后的结果，U2’=R3/（R3+R4）*U2。**

**应用中应该注意：两端的输入阻抗是不想等的，要注意输入偏置电流引起的误差。**

#### 9.2.6 微分器

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/微分器.png)

此电路并非实际应用形式，由于6dB/2倍频的交流增益特性，其对高频噪声敏感。**反馈电路RC组成了等效低通滤波**，但是在反馈环有90°相角超前，仍存在稳定性问题。

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/微分器实际应用关系式.png)

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/微分器应用.png)

**R2C2构成6dB/2的高频衰减，R1C1构成6dB/2的倍频衰减，总体呈现12dB/2高频衰减，抑制高频噪声。**R1C1、R2C2一同构成一个网络，频点若设定在运放的单位增益带宽内，C2将强制滞后R2相位，用于抵消C1带来的相角超前。

#### 9.2.7 积分器

![](https://raw.githubusercontent.com/MicroPrism/All-image/main/C51/积分器.png)

**本质上，积分器为6dB/2倍频的LPF，需要增加初始化电路，以创造积分器工作的初始化条件（s开关）。**S=1时，工作在跟随器状态，C1电荷释放。S=2时，工作在积分器状态，输出是输入电压对时间积分与常数之积。

使用时需要注意：运放在单位增益状态下应该能稳定；**R1=R2减小输入偏置电压误差（此处没有反馈电阻，若有，则功能同反相放大器，减小偏置电流带来的偏置电压）**。