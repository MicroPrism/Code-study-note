#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//数组长度：元素个数
//操作符问题--符号位运算的时候不再为符号位
struct Book
{
	char name[20];
	char id[20];
	char price;
};
int main()
{
	//1.算术操作符：+、-、*、/、%
	{
		//1.1  /
		{
			float a = 0, b = 0;
			a = 3 / 2;//商1余1
			b = 3.0 / 2;
			printf("a=%f\n", a);//1.0
			printf("b=%f\n", b);//1.5
		}
		//如果需要得到小数，分母分子至少有一个小数
		//1.2 %-两端必须为整数
	}

	//2.移位操作符 >>,<<:移二进制位
	{
		//2.1左移操作符<<:左侧丢弃，右侧补0
		{
			int c = 2, d = 0;
			d = c << 1;
			printf("c=%d\n", c);//2-0010
			printf("d=%d\n", d);//4-0100
		}
		//2.2右移操作符>>:右侧丢弃
		//2.2.1算术右移：左边丢弃，补原符号位
		{
		int e = -2, f = 0;
		f = e >> 1;
		printf("e=%d\n", e);//-2-1...0010
		printf("f=%d\n", f);//-1-1...0001
		//正数：原码=反码=补码
		//负数：原码（除符号位）取反=补码，补码+1=反码
		//负数以反码形式存储，移位也是移动反码
		//-1=10000000......00000001，补码11111111......11111110，反码11111111......11111111
		//移位移反码，因此若为算数移位，值不变；若为逻辑移位，反码变为01111111......11111111,为2^30
		}
		//2.2.2逻辑右移：左边丢弃，补0
	}

	//3.（按位）与&、或|、非^
	{
		// |可以实现变量的值交换
		int r = 1, s = 2, t = 0;
		//加法
		{
			r = r + s;
			s = r - s;
			r = r - s;
		}//可以实现交换，但r+s可能太大会溢出，数据丢失
		//异或法：a^a=0;0^a=a;
		{
			r = r ^ s;//r相当于一个中间变量，而已！
			s = s ^ r;
			r = r ^ s;
		}//r=011;s=001;r=010;交换--
		//例1：计算某个数对应二进制补码1的个数
		{
			int o = 7, count = 0;
			while (1)
			{
				//o&1是末位的值，如果需要确定其他位的值，只需要调整1的位置
				//比如o&2【也可写为o&（1<<1）】，可以确定倒数第二位是否为1，判断运算结果o&2==2或者是否为真即可，
				if (o & 1)
				{
					o = o >> 1;
					count++;
				}
				if (o == 0)
				{
					break;
				}
			}
			printf("1的个数:%d\n", count);
		}
	}

	//4.赋值语句-可以连续赋值，从右想左赋值，但是不建议连续
	//int r=s= 2*t + 1;

	//5.单目操作符
	{
		//5.1 ！若a为真，！a为假;
		//5.2 sizeof,计算变量大小时可以取消括号，sizeof a;sizeof(int)
		{
			int arr[10] = { 0 };
			sizeof(arr);
			sizeof(int[10]);//结果相同，arr变量类型为int 个数10
			short x = 5;
			int y = 10;
			printf("%d\n", sizeof(x = y + 2));//2;表达式x = y + 2不参与计算， sizeof(x = y + 2)在编译时视为一个结果
			//sizeof括号内表达式，不参与运算
			printf("%d\n", x);//5
		}
		//5.3 ~按位取反，不同于原码反码补码的运算，~操作时符号位也取反
		{
			//11111111......10111111
			//~(00000000......01000000),即~(1<<6),实现多个1的操作
		}
		//5.4 ++、--前置后置
		//5.5 &取址
		{
			int a = 0;
			&a;
			int* pa=&a;
			*pa;
		}
		//5.6 (类型)：强制类型转换	
	}
	//6.双目
	{
		//6.1比较操作>=,<=,==,!=,>,<
		//6.2逻辑与&&、或||
		{
			//对于复杂的逻辑表达式，可能出现逻辑短路
			//&&：出现0时后续不再计算
			//||：出现1时后续不再计算
		}
	}
	//7.三目（）？（）：（）
	//8.，逗号表达式是括号括起来的一串表达式，其内部表达式依次执行
	//如果使用逗号表达式赋值，最终结果为最后一个表达式
	//9.[]下标引用操作符-引用数组元素；；（）：函数调用操作符--要传参的
	//10.   . ->结构体成员访问操作符
	{

		int num = 10;
		struct Book control = { "自控","123456",53 };
		printf("%s\t%s\t%d\n", control.name,control.id,control.price);
		struct Book* pcontrol = &control;//结构体首地址需要取址
		printf("%s\t%s\t%d\n", (* pcontrol).name, (*pcontrol).id, (*pcontrol).price);//（*指针）.取内容
		printf("%s\t%s\t%d\n",  pcontrol->name, pcontrol->id, pcontrol->price);//指针->内容，指向不需要解引用
	}
	//11.字符相加
	{
		char a = 3;
		char b = 127;
		char c = a + b;
		printf("%d\n", c);
		//整形提升，如果无符号（首位不是符号位），补0；否则，补符号位
		//负数：-1,补码1111 1111，扩展到4字节1111...1111 1111，高位全补1
		//正数：1，补码0000 0001，扩展后0000...0000 0001，高位补0
		//a：0000 0010,提升0000...0000 0010
		//b:0111 1111,提升后 0000...0111 1111
		//a+b=0000 ... 1000 0010,截断c=1000 0010
		//%d打印，再提升 1111...1000 0010，反码为1111...1000 0001,补码1000...0111 1110
		char d = 0xb6;
		short e = 0xb600;
		int f = 0xb6000000;
		if (d == 0xb6)//if判断语句判断的是整型，char d提升为int型再参与判断
		{
			printf("d");
		}
		if (e == 0xb600)
		{
			printf("e");
		}
		if (f == 0xb6000000)
		{
			printf("f\n");
		}
		//注意字符型变量只要参与运算，+、-、！就会进行整形提升，sizeof（+c）；输出4
		//int a,b;a+b;表达式a+b同时具有值属性和类型属性，sizeof计算只看类型
	}
	//12.算术转换
	{
		//两个类型不同时，向更高精度的类型转化
	}
	//13.操作符的属性1.优先级2.结合性3.是否控制求值顺序
	{
		//优先级越高，越先进行计算；同优先级，结合性（左结合、右结合）决定计算顺序
		//问题表达式:a*b+c*d+e*f
		//先计算a*b+c*d再加e*f，还是先计算乘式再加，会有两种结果，不确定表达式e*f是否会影响到之前的值
		int i = 1;
		printf("%d\n", (++i) + (++i) + (++i));//12,但是在Linux系统里输出10
		//避免写出有歧义的代码
	}
	return 0;
}