#define _CRT_SECRE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>
//release版本可能会做出优化
int main()
{
	{
		int i = 0;
		int arr[9] = { 1,2,3,4,5,6,7,8,9 };
		printf("%p\n", &i);//0036FCC0     //00BAF9C4  relaese版本自动将i放在低地址，不会出现数组越界改变变量的情况
		printf("%p\n", &arr[9]);//0036FCB8  //00BAF9EC
		//左侧地址位debug版本，右侧为release版本
	}
	
	//数据类型--为该类型变量开辟相应的内存空间大小
	{
		//整形-char、short、int、long，均包括unsigned 与signed
		//浮点型-float、double
		//构造类型/自定义类型-数组、struct、union、enum
		//指针类型
		//空类型-void，函数返回类型、函数参数、指针、
	}
	//原反补
	{
		int a = -10;//补码=原码取反+1；原码=补码取反+1；
		//10000000 ……00001010
		//11111111 ……11110101
		//11111111 ……11110110
		//f   f    fffff   6
		//CPU只有加法器没有减法，需要存储补码
		//1-1=1+(-1)
		//源码直接相加结果有误
		//00000000……00000001
		//10000000……00000001
		//10000000……00000010=-2
		//补码
		//11111111……11111111
		//（进位1丢失）00000000……0000000=0
		int b = 10;
		//0a 00 00 00
	}
	//大端字节序/小端字节序
	{
		int a = 0x11223344;//其存储时从低到高存储 11 22 33 44或者44 11 22 33……均可
		//大端：11 22 33 44，低位字节序放在高位地址
		//小端：44 33 22 11  低位字节序放在低位地址---看起来是倒着存储的
		//计算机中，以字节为单位，每个地址都对应一个字节
		//x86系统，为小端存储，keil c51中为大端存储
	}

	//判断当前机器字节序
	{
		int a = 0x00000001;
		char* p = (char*) & a;//使用char*访问第一个字节,如果低地址存放低字节
		printf("%d\n", *p);
	}
	//整形提升问题-强行扩展为多个字节
	{
		//1.
		char a = -1;//补码进行整型提升，补符号位
		unsigned char b= -1;//无符号，整型提升补0
		signed char c = -1;// 补码进行整型提升，补符号位
		printf("%d  %d  %d\n",a,b,c);
		//char为unsigned还是signed取决于编译器
		//int为signed int 
		
		//2.
		char e = -128;
		printf("%u\n", e);//很大的数
		//-128首先是整型负数，补码存储，再去赋值给char
		//原码：1000000 00……00 10000000；补码：111111111……10000000
		//再将-128补码赋值给char e，e=10000000，char补符号位
		//unsigned int打印时再次进行整形提升 11111111……10000000，无符号型打印
		
		//3.
		char f = 128;
		printf("%u\n", f);
		//与2类似，e=10000000，整形提升后11111111……10000000

		/*对于有符号char型数据，0000 0001-0111 1111属于整数，
		再加一，1000 0000整形提升后值为-128，从1000 0000-11111111值从-128变为-1
		有符号char值为-128~127
		*/
		
		//4.
		int i = -20;
		//1000……10100-》1111……01100
		unsigned int j= 10;
		//0000……01010
		//1111……10110-》1000……01010=-10
		printf("%d\n", i + j);
	}

	//{
	//	unsigned int i = 0;
	//	for (i = 9; i >= 0; i--)//i=0之后再--又会变为正数/死循环，无符号数没有负数
	//	{
	//		printf("%u\n", i);
	//	}
	//}
	
	{
		char a[1000];
		int i;
		for (i = 0; i < 1000; i++)
		{
			a[i] = -1 - i;
			//-1：10000000 ……00000001-》11111111……11111111，截断后a[0]:11111111-》10000001  -1
			//-2：10000000 ……00000010-》11111111……11111110，截断后a[1]=11111111-》10000010  -2
			//...
			//-128:10000……10000000-》11111111……10000000，    a[128]:10000000-》10000000  -128
			//-129:10000……10000001-》11111111……01111111，    a[129]:01111111正数127
			//对于有符号字符型0-》127-》-128-》-1-》0不断循环
		}
		printf("%d", strlen(a));
	}
	
	//浮点型存储方式
	{
		/*
		对于单精度型，表示为(-1)^S*M*2^E;例如5.5=101.1=(-1)^0*1.011*2^2
		计算机在存储时4字节，32bit位，最高位为符号位S，其后8bit存放次幂E+127（或1023），剩余23bit位存放M
		对于32位，E+127；对于64位，E+1023
		存储时为0 10000001 011000000000000；S=0；E=2+127=129；M=011，后方补0，不存储必定存在的整数1
		*/
		int n = 9;
		float* pFloat = (float*)&n;//转换格式按照float解码
		printf("%d\n%f\n", n, *pFloat);
		//二进制码00000000000000000000000000001001
		//float识别0 00000000 00000000000000000001001，E=0-127=-127，识别结果为0
		*pFloat = 9.0;//1001.0=1.001*2^3，E=3+127=130
		//9.0按照float型存储
		printf("%d\n%f\n", n, *pFloat);
		//float识别为0 10000010 00100000000000000000000000
		//按整形二进制识别会输出为非常大的数 
	
	}
	return 0;
}
